const char debugMSG[]	  = "[@LearningDistributor]"

const char ALTERNATE[]  = "alternate"
const char PROPAGATE[]  = "propagate"
const char SHARDING[]   = "sharding"
const char LOCAL[]      = "local"

component provides distributor.LearningDistributor requires io.Output out, data.StringUtil strUtil, data.IntUtil iu, io.Input in, 
	monitoring.Perception, data.json.JSONEncoder encoder, data.DecUtil du, time.Timer t, learning.UCB{

	String remoteConfigs[] 		= null
	String localConfigs[] 		= null
	String distributedProxies[] = null
	Perception perception 		= null
	UCB learning = null

	LearningDistributor:LearningDistributor() {
		perception = new Perception(true)
		/* Loading target system and adding a monitoring proxy to it */


		// todo

		perception.setMain("../../server/main.o", null)
		perception.addProxy("|../../distributor/monitoring/proxies/ServerProxy.o|*(*:server.Server[0]:*)|")
		String configs[] = perception.getAllConfigs()
		for (int i = 0; i < configs.arrayLength; i++) {
			out.println("$(debugMSG) $(iu.intToString(i+1)): $(configs[i].string)")
		}
		loadDistributedProxies()
		remoteLocalSeparation()
		local()
	}

	String[] getConfigs() {
		// todo remove hardcoded dependency 
		return new String[](new String(LOCAL),
							new String(PROPAGATE),
							new String(SHARDING),
							new String(ALTERNATE))
	}

	void local() {
		perception.setConfig(localConfigs[0].string)
		out.println("$(debugMSG) Local composition running.")
	}

	void distribute(char proxyInterface[]) {
		out.println(proxyInterface)

		char remoteConfig[] = getRemoteConfig("data/adt/$(proxyInterface)")
		if (remoteConfig != null) {	
			perception.setConfig(remoteConfig)
			out.println("$(debugMSG) Remote composition [($proxyInterface)] running.")	
		} else {
			throw new Exception("Something went wrong! Couldn't find remote proxy.")
		}
	}



	void commandInterpret(char cmd[]) {
		String cmdList[] = strUtil.explode(cmd, " ")
		if (cmdList.arrayLength == 1) {
			if (cmd == PROPAGATE) {
				distribute("ListCPPropagate.o")
			} else if (cmd == ALTERNATE) {
				distribute("ListCPAlternate.o")
			} else if (cmd == SHARDING) {
				distribute("ListCPSharding.o")
			} else if (cmd == LOCAL) {
				local()
			} else {
				out.println("Invalid command.")
			}
		}
	}

	char[] getRemoteConfig(char proxy[]) {
		for (int pointer = 0; pointer < remoteConfigs.arrayLength; pointer++) {
			if (strUtil.find(remoteConfigs[pointer].string, proxy) != StringUtil.NOT_FOUND) {
				return remoteConfigs[pointer].string
			}
		}
		return null
	}

	// Guess there's a better way of doing this...
	void remoteLocalSeparation() {
		if ((remoteConfigs == null) || (localConfigs == null)) {
			out.println("$(debugMSG) Separating local and remote compositions...")
			String configs[] = perception.getAllConfigs()
			for (int confPointer = 0; confPointer < configs.arrayLength; confPointer++) {
				bool remote = false
				for (int distProxy = 0; distProxy < distributedProxies.arrayLength; distProxy++) {
					if (strUtil.find(configs[confPointer].string, distributedProxies[distProxy].string) 
						!= StringUtil.NOT_FOUND) {
						remoteConfigs = new String[](remoteConfigs, configs[confPointer])
						remote = true
						break
					}
				}
				if (!remote) {
					localConfigs = new String[](localConfigs, configs[confPointer])
				}
			}
		}
	}

	// TODO: dynamically load the names of distributed proxies from the folder distributor/data/adt/
	// currently hard-coded 
	void loadDistributedProxies() {
		if (distributedProxies == null) {
			distributedProxies = new String[](
				new String("ListCPPropagate.o"),
				new String("ListCPAlternate.o"),
				new String("ListCPSharding.o"))
		}
	}

	void LearningDistributor:setupLearning() {
		String configs[] = getConfigs()
		learning = new UCB(configs.arrayLength)
	}

	int LearningDistributor:distributeByLearning() {
		String configs[] = getConfigs()
		int index = learning.chooseCompositionIndex()
		String chosenConfig = configs[index]
		commandInterpret(chosenConfig.string)

		return index
	}

	void LearningDistributor:updateReward(int config, dec responseTime) {
		dec reward = 100 / responseTime
		learning.update(config, reward)
	}
}

