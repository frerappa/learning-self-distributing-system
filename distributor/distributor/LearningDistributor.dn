const char debugMSG[]	  = "[@LearningDistributor]"

const char LOCAL[]      = "local"

component provides distributor.LearningDistributor requires Distributor distributor, io.Output out, io.File, 
	data.StringUtil strUtil, data.IntUtil iu, time.Timer t, data.DecUtil du, io.Input in, learning.UCB, learning.EpsilonGreedy {

	int currentConfigIndex = 0
	String configs[] = null
	UCB learning = null
	// EpsilonGreedy learning = null

	bool write = false

	LearningDistributor:LearningDistributor(opt bool outputToFile) {
		distributor.start()
		configs = distributor.getConfigs()
		write = outputToFile
	}

	int distributeByLearning() {
		int index = learning.chooseCompositionIndex()
		if (currentConfigIndex != index) {
			String chosenConfig = configs[index]
			out.println("ChosenConfig: $(chosenConfig.string)")
			distributor.setConfig(chosenConfig.string)
		}
		currentConfigIndex = index
		return index
	}

	void updateReward(int config, dec reward) {
		learning.update(config, reward)
	}

	dec averageResponseTime(Metric m) {
		out.println("IV $(iu.intToString(m.value)) / $(iu.intToString(m.counter)) ")
		dec value =  m.value
		dec counter = m.counter
		return value / counter 
	}

	dec calculateReward(dec responseTime) {
		return 100.0 / responseTime
	}

	void observationLoop(int observationWindow) {
		t.sleep(observationWindow)
	}


	void LearningDistributor:run() {
		learning = new UCB(configs.arrayLength)
		// learning = new EpsilonGreedy(0.1, configs.arrayLength)
		PerceptionData perception = null

		while (1) {
			observationLoop(7500)
			perception = distributor.getPerceptionData()
			for (int j = 0; j < perception.metrics.arrayLength; j++) {
				if (perception.metrics[j].name == "response_time") {

					dec responseTime = averageResponseTime(perception.metrics[j])

					dec reward = calculateReward(responseTime)

					updateReward(currentConfigIndex, reward)

					distributeByLearning()
				}
			}
		}
	}
}

